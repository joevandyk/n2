#
# Borrowed from: https://github.com/webficient/capistrano-recipes
#
#
# Copyright (c) 2009-2011 Webficient LLC, Phil Misiowiec
# 
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

    <% if is_using_unicorn %>
    upstream <%= application %>_app_server {
        server unix:<%= unicorn_socket %> fail_timeout=0;
    }
    <% end %>
    <% if is_using_passenger %>
    upstream <%= application %>_app_server {
        server unix:<%= passenger_socket %> fail_timeout=0;
    }
    <% end %>
    # <%= application %> Server
    server {
        listen <%= application_port %>;
        client_max_body_size 500M;
        server_name <%= base_url %>;

        # ~2 seconds is often enough for most folks to parse HTML/CSS and
        # retrieve needed images/icons/frames, connections are cheap in
        # nginx so increasing this is generally safe...
        keepalive_timeout 5;

        # path for static files
        root <%= deploy_to %>/current/public;
        #access_log <%= deploy_to %>/current/log/nginx.access.log main;
        #error_log  <%= deploy_to %>/current/log/nginx.error.log info;
        access_log <%= nginx_access_log_path %>;
        error_log <%= nginx_error_log_path %>;

        # this rewrites all the requests to the maintenance.html
        # page if it exists in the doc root. This is for capistrano's
        # disable web task
        if (-f $document_root/system/maintenance.html) {
          rewrite  ^(.*)$  /system/maintenance.html last;
          break;
        }
        
        location / {
          
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header Host $http_host;
          
          # If the file exists as a static file serve it directly without
          # running all the other rewite tests on it
          if (-f $request_filename) { 
            break; 
          }

          # check for index.html for directory index
          # if its there on the filesystem then rewite 
          # the url to add /index.html to the end of it
          # and then break to send it to the next config rules.
          if (-f $request_filename/index.html) {
            rewrite (.*) $1/index.html break;
          }

          # this is the meat of the rails page caching config
          # it adds .html to the end of the url and then checks
          # the filesystem for that file. If it exists, then we
          # rewite the url to have explicit .html on the end 
          # and then send it on its way to the next config rule.
          # if there is no file on the fs then it sets all the 
          # necessary headers and proxies to our upstream mongrels
          if (-f $request_filename.html) {
            rewrite (.*) $1.html break;
          }
          
          <% if is_using_unicorn or is_using_passenger %>
          if (!-f $request_filename) {
            proxy_pass http://<%= application %>_app_server;
            break;
          }
          <% end %>

        }
        
        # Now this supposedly should work as it gets the filenames with querystrings that Rails provides.
        # BUT there's a chance it could break the ajax calls.
        location ~* \.(ico|css|gif|jpe?g|png)(\?[0-9]+)?$ {
        	 expires max;
        	 break;
        }
        
        location ~ ^/javascripts/.*\.js(\?[0-9]+)?$ {
        	 expires max;
        	 break;
        }
        
        # Rails error pages
        error_page 500 502 503 504 /500.html;
        location = /500.html {
          root <%= deploy_to %>/current/public;
        }
    }
    
    <% if application_uses_ssl %>
      
    <% if is_using_unicorn %>
    upstream <%= application %>_app_ssl {
      server unix:<%= unicorn_socket %> fail_timeout=0;
    }  
    <% end %>
    <% if is_using_passenger %>
    upstream <%= application %>_app_ssl {
      server unix:<%= passenger_socket %> fail_timeout=0;
    }  
    <% end %>
    
    # This server is setup for ssl. Uncomment if 
    # you are using ssl as well as port 80.
    server {
      listen <%= application_port_ssl%>;
      server_name <%= application %>;
      ssl                     on;
      ssl_certificate         /etc/ssl/certs/server.crt;
      ssl_certificate_key     /etc/ssl/private/server.key;
      ssl_session_timeout     5m;
      client_max_body_size    50M;
      
      root <%= deploy_to %>/current/public;
      #access_log <%= deploy_to %>/current/log/nginx.access.log main;
      #error_log  <%= deploy_to %>/current/log/nginx.error.log info;
      access_log <%= nginx_access_log_path %>;
      error_log <%= nginx_error_log_path %>;

      # this rewrites all the requests to the maintenance.html
      # page if it exists in the doc root. This is for capistrano's
      # disable web task
      if (-f $document_root/system/maintenance.html) {
        rewrite  ^(.*)$  /system/maintenance.html last;
        break;
      }

      location / {
        
        # needed to forward user's IP address to rails
        proxy_set_header  X-Real-IP  $remote_addr;

        # needed for HTTPS
        proxy_set_header X_FORWARDED_PROTO https;

        proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Host $http_host;
        proxy_redirect off;
        proxy_max_temp_file_size 0;

        
        # If the file exists as a static file serve it directly without
        # running all the other rewite tests on it
        if (-f $request_filename) { 
          break; 
        }

        # check for index.html for directory index
        # if its there on the filesystem then rewite 
        # the url to add /index.html to the end of it
        # and then break to send it to the next config rules.
        if (-f $request_filename/index.html) {
          rewrite (.*) $1/index.html break;
        }

        # this is the meat of the rails page caching config
        # it adds .html to the end of the url and then checks
        # the filesystem for that file. If it exists, then we
        # rewite the url to have explicit .html on the end 
        # and then send it on its way to the next config rule.
        # if there is no file on the fs then it sets all the 
        # necessary headers and proxies to our upstream mongrels
        if (-f $request_filename.html) {
          rewrite (.*) $1.html break;
        }
        
        <% if is_using_unicorn %>
        if (!-f $request_filename) {
          proxy_pass http://<%= application %>_app_ssl;
          break;
        }
        <% end %>
      }

      error_page   500 502 503 504  /500.html;
      location = /500.html {
        root   <%= deploy_to %>/current/public;
      }
    }
    <% end %>  
